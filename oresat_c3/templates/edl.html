{% extends "base.html" %}

{% block content %}
<style>
  #codeSelect {
    flex: 1;
    margin-right: 10px;
  }

  #args {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
  }
  
  #argsTable {
    width: 30%;
    border-collapse: collapse;
    margin: 20px auto;
    text-align: left; 
  }
  
  #argsTable td {
    border: 1px solid #ddd;
  }
  
  .param-cell {
    text-align: center;
    vertical-align: middle; 
  }
  
  .param {
    width: 100%;
    max-width: calc(100% - 10px);
    border: 0px solid #ddd;
    
  }

  #submitButton {
    flex: 0;
  }
</style>

<select id="codeSelect"></select>
  
<form id="args">
  <table id="argsTable"></table>
</form>
<div id="responseDiv"></div>
<button id="submitButton" type="submit">Send</button>

<script>
  class Command 
  {
    constructor(code, name, desc, paramNames, paramCtors, retType) {
      this.code = code;
      this.name = name;
      this.desc = desc;
      this.paramNames = paramNames;
      this.paramCtors = paramCtors;
      this.retType = retType;
    }
  } 

  function getNodeSelect() 
  {
        const NODES = {
        0x18: 'Battery 1',
        0x19: 'GPS',
        0x1A: 'ACS',
        0x1B: 'DxWiFi',
        0x1C: 'Star Tracker',
        0x1D: 'CFC Processor',
        0x1E: 'CFC Sensor',
        0x1F: 'Battery 2',
        0x20: 'Reaction Wheel 1',
        0x21: 'Reaction Wheel 2',
        0x22: 'Reaction Wheel 3',
        0x23: 'Reaction Wheel 4',
      };

      const selectElement = document.createElement("select");
      selectElement.classList.add("param");

    // add options to the select element
    for (const [value, text] of Object.entries(NODES)) 
    {
      const optionElement = document.createElement("option");
      optionElement.value = value;
      optionElement.textContent = text;
      selectElement.appendChild(optionElement);
    }
    return selectElement;
  };
  
  let objects;

  async function readAllObjects() 
  {
    objects = await fetch(`http://${window.location.host}/od-all`)
      .then(response => response.json())
      .then(data => {
        if (data.error !== undefined) {
          console.log(data);
        }
        return data;
      });
  }


  function getIndexSelect() 
  {
    const indexSelect = document.createElement("select");
    indexSelect.setAttribute("id", "indexSelect");
    indexSelect.onchange = updateSubindexSelect
    for (const index in objects) {
      let indexHex = "0x" + parseInt(index).toString(16).toUpperCase();
      let opt = document.createElement("option");
      opt.value = indexHex;
      opt.innerHTML = `${indexHex} - ${objects[index].name}`;
      indexSelect.appendChild(opt);
    }

    const subindexSelect = document.createElement("select");
    subindexSelect.setAttribute("id", "subindexSelect");

    return [indexSelect, subindexSelect];
  };

  function updateSubindexSelect() 
  {
    const indexSelect = document.getElementById("indexSelect");
    const subindexSelect = document.getElementById("subindexSelect");
    const index = parseInt(indexSelect.value, 16);
    const obj = objects[index];

    // clear select options
    subindexSelect.options.length = 0

    let opt = document.createElement("option");
    opt.value = "";
    opt.innerHTML = "None";
    subindexSelect.appendChild(opt);

    if (obj.subindexes === undefined)
      subindexSelect.disabled = true;
    else 
    {
      subindexSelect.disabled = false;
      for (const subindex in objects[index].subindexes) {
        let subindexHex = "0x" + parseInt(subindex).toString(16).toUpperCase();
        let opt = document.createElement("option");
        opt.value = subindexHex;
        opt.innerHTML = `${subindexHex} - ${objects[index].subindexes[subindex].name}`;
        subindexSelect.appendChild(opt);
      }
    }
  }

  function getBoolSelect() 
  {
    const selectElement = document.createElement("select");
    const trueOption = document.createElement("option");
    trueOption.value = true;
    trueOption.textContent = "True";

    const falseOption = document.createElement("option");
    falseOption.value = false;
    falseOption.textContent = "False";

    selectElement.appendChild(trueOption);
    selectElement.appendChild(falseOption);
    selectElement.classList.add("param");

    return selectElement;
  }

  function getIntTextInput(name) 
  {
    const paramTextbox = document.createElement("input");
    paramTextbox.type = "text";
    paramTextbox.placeholder = name;
    paramTextbox.classList.add("param");

    paramTextbox.addEventListener("input", function() {
    
    // Attempt to convert the user's input to an integer
    paramTextbox.value = parseInt(paramTextbox.value);
    
    // Check if the conversion was successful
    if (!isNaN(paramTextbox.value))
      console.log("Converted integer value:", paramTextbox.value);
    else
      console.log("Invalid input, not an integer");
    })

    return paramTextbox;
  }

  function getTextInput(name) 
  {
    const paramTextbox = document.createElement("input");
    paramTextbox.type = "text";
    paramTextbox.placeholder = name;
    paramTextbox.classList.add("param");
    return paramTextbox;
  }

  const commands = [
    new Command(0, "TX_CTRL", "Enable or disable Tx. Parameters: enable - True to enable Tx or False to disable Tx. Returns: Tx status.", ["enable: bool"], [getBoolSelect], ["bool"]),
    new Command(1, "C3_SOFT_RESET", "Soft reset the C3 (reboot C3 daemon).", [], [], []),
    new Command(2, "C3_HARD_RESET", "Hard reset the C3 (reboot system).", [], [], []),
    new Command(3, "C3_FACTORY_RESET", "Factory reset the C3 (clear FRAM, reset RTC, and reboot system).", [], [], []),
    new Command(4, "CO_NODE_ENABLE", "Enable a CANopen node. Parameters: node_id - Node id of the CANopen node to enable / disable. enable - True to enable or False to disable. Returns: Node status.", ["node_id: uint8", "enable: bool"], [getNodeSelect, getBoolSelect], ["int"]),
    new Command(5, "CO_NODE_STATUS", "Get the status of a CANopen node. Parameters: node_id - Node id of node to get the status for. Returns: Node status.", ["node_id: uint8"], [getNodeSelect], ["int"]),
    new Command(6, "CO_SDO_WRITE", "Write a value to a node's OD over the CAN bus using a CANopen SDO message. Parameters: node_id - The id of The CANopen node to write to. index - The OD index to write to. subindex - The OD subindex to write to. size - Size of the data buffer. buffer - Data buffer. Returns: SDO error code (0 is no error).", ["node_id: uint8", "index: int", "size: uint32", "buffer: bytes"], [getNodeSelect, getIndexSelect, getIntTextInput, getTextInput], ["int"]),
    new Command(7, "CO_SYNC", "Send a CANopen SYNC message on the CAN bus. Returns: The CANopen SYNC message was sent successfully.", [], [], ["bool"]),
    new Command(8, "OPD_SYSENABLE", "Enable the OPD subsystem. Parameters: enable - True to enable or False to disable. Returns: OPD subsystem status.", ["enable: bool"], [getBoolSelect], ["bool"]),
    new Command(9, "OPD_SCAN", "Scan for all nodes on the OPD. Returns: The number of nodes found.", [], [], ["int"]),
    new Command(10, "OPD_PROBE", "Probe for a node on the OPD. Parameters: node_id - The id of the OPD node to probe for. Returns: True if the node was found or False if not.", ["node_id: uint8"], [getNodeSelect], ["bool"]),
    new Command(11, "OPD_ENABLE", "Enable or disable a node on the OPD. Parameters: node_id - The id of the OPD node to enable / disable. enable - True to enable or False to disable. Returns: OPD node status.", ["node_id: uint8", "enable: bool"], [getNodeSelect, getBoolSelect], ["int"]),
    new Command(12, "OPD_RESET", "Reset a node on the OPD. Parameters: node_id - The id of the OPD node to reset. Returns: OPD node status.", ["node_id: uint8"], [getNodeSelect], ["int"]),
    new Command(13, "OPD_STATUS", "Get the status of a node on the OPD. Parameters: node_id - The id of the OPD node to get the status of. Returns: OPD node status.", ["node_id: uint8"], [getNodeSelect], ["int"]),
    new Command(14, "RTC_SET_TIME", "Set the RTC time. Parameters: time - The unix time in seconds. Returns: The RTC time was set successfully.", ["time: uint32"], [getIntTextInput], ["bool"]),
    new Command(15, "TIME_SYNC", "C3 will send OreSat's Time Sync TPDO over the CAN bus (all nodes that are powered on and care about time will sync to it). Returns: Time sync was sent.", [], [], ["bool"]),
];


  // Get handles to HTML elements
  let codeSelect = document.getElementById("codeSelect");
  let args = document.getElementById("args");  
  let submitButton = document.getElementById("submitButton");
  let responseDiv = document.getElementById("responseDiv");
  let argsTable = document.getElementById("argsTable");

  // On page load, create list of commands to choose from
  commands.forEach((command) => {
    const optionElement = document.createElement("option");
    optionElement.value = command.code.toString();
    optionElement.textContent = command.name;
    codeSelect.appendChild(optionElement);
  });
  codeSelect.value = "0";

  // Callback when form is submitted
  submitButton.onclick = submit
  async function submit()
  {

  // Get the selected code
  let code = document.getElementById("codeSelect").value;
  
  // TODO: Check the args here

  let responseJSON = await SendCommand(code)
  
  // Display response value (if there is one)
  if (commands[code].retType.length != 0)
    responseDiv.textContent = JSON.stringify(responseJSON, null, 2);
  };

  async function SendCommand(code) 
  {
    const url = `http://${window.location.host}/static/edl/c3-cmd/${code}`;
    
    let requestData = {};

    // Create an array to store input elements
    let inputList = [];

    // Iterate through form elements
    for (let i = 0; i < args.elements.length; i++) 
    {
      const element = args.elements[i];
      if (element.tagName === "INPUT" || element.tagName === "SELECT")
      {
        try {inputList.push(element.value);} 
        catch (e) {return e.message;}
      }
    }

    // Send request with args in JSON
    requestData.args = inputList;
    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestData),
    });

    let json = await response.json();
    return json;
}

function convertType(value, type) 
{
    let convertedValue;
    if (type === "bool") 
    {
      if (value.toLowerCase() === 'true' || value.toLowerCase() === 't') {convertedValue = true;}
      else if (value.toLowerCase() === 'false' || value.toLowerCase() === 'f') {convertedValue = false;}
      else {throw new Error('Error: ' + value + ' is not true or false');}     
    } 
    else if (type === "int") {convertedValue = parseInt(value);} 
    else  // Bytes 
    { 
      convertedValue = btoa(value);
    } 

    return convertedValue;
}

  // Triggers when an option is changed
  codeSelect.onchange = updateCodeSelect

  async function updateCodeSelect(value, type) 
  {
    const code = parseInt(codeSelect.value);

    // Load OD
    await readAllObjects();

    // Clear existing rows
    argsTable.innerHTML = "";

    // Create a new row for the description
    let descriptionRow = document.createElement("tr");
    let descriptionCell = document.createElement("td");
    descriptionCell.textContent = commands[code].desc;
    descriptionCell.colSpan = commands[code].paramNames.length; // Span the entire row
    descriptionRow.appendChild(descriptionCell);
    argsTable.appendChild(descriptionRow);

    // If the selected option has parameters, add another row for them
    if (commands[code].paramNames.length > 0) 
    {
      const parametersRow = document.createElement("tr");
      for (let i = 0; i < commands[code].paramNames.length; i++) 
      {
        let paramCell = document.createElement("td");
        paramCell.classList.add("parameter-cell");
        if (commands[code].paramCtors[i] === getIntTextInput || commands[code] === getTextInput)
        {
          let paramElement = commands[code].paramCtors[i](commands[code].paramNames[i])  // Pass in param name
          paramCell.appendChild(paramElement)
          parametersRow.appendChild(paramCell);
        }
        else if (commands[code].paramCtors[i] === getIndexSelect)
        {
          let paramElement = commands[code].paramCtors[i]()
          paramCell.appendChild(paramElement[0])
          parametersRow.appendChild(paramCell);

          paramCell.appendChild(paramElement[1])
          parametersRow.appendChild(paramCell);
        }
        else
        {
          let paramElement = commands[code].paramCtors[i]()
          paramCell.appendChild(paramElement)
          parametersRow.appendChild(paramCell);
        }
      }

      // Set the custom property for parameter count
      parametersRow.style.setProperty("--parameter-count", commands[code].paramNames.length);

      argsTable.appendChild(parametersRow);
      //updateSubindexSelect();

    }
  };

  // Trigger the event to display the first option when the page loads
  codeSelect.dispatchEvent(new Event("change"));
</script>
{% endblock %}